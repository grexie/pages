(()=>{"use strict";const e=()=>{const e={},t=new Promise(((t,o)=>{let n=!1;Object.assign(e,{get resolved(){return n},resolve:e=>{n=!0,t(e)},reject:e=>{n=!0,o(e)}})}));return Object.assign(t,e),t};const t=self,o="grexie-cloud-v1.0.0",n={};function s(e){if("opaque"===e.type||"opaqueredirect"===e.type)return e;const t=e.clone();return("body"in t?Promise.resolve(t.body):t.blob()).then((async e=>{const o={};for(const e in t.headers.keys())o[e]=t.headers.get(e);return delete o["X-Frame-Options"],delete o["X-Content-Type-Options"],new Response(e,{headers:t.headers,status:t.status,statusText:t.statusText})}))}t.addEventListener("install",(t=>{console.info("installing..."),t.waitUntil((async()=>{const t=await caches.open(o);let s;try{const e=await fetch("/assets/site-manifest.json");a.resolve(e.json()),s=(await a).files}catch(e){s=[]}const c=await(async e=>{const t=new URL(location.href);t.pathname="/",t.search="";const o=await e.keys(t);let n=[];for(const e of o){const t=e;"string"==typeof e?n.push(new URL(e,location.href).pathname):n.push(new URL(t.url,location.href).pathname)}return n})(t);for(const e of c)s.includes(e)&&s.splice(s.indexOf(e),1);const r=new Set(c);for(const e of c)s.includes(e)&&r.delete(e);for(const e of r)console.info("deleting",e),t.delete(new URL(e,location.href));setTimeout((()=>{self.navigator.onLine&&(console.info("caching",s.length,"files",s),Promise.all(s.map((async o=>{const s=new URL(o,location.href).toString(),a=e();n[s]=a;try{const e=await t.match(s);if(e?.headers.get("etag")){const t=await fetch(s,{method:"HEAD"});if(e.headers.get("etag")===t.headers.get("etag"))return a.resolve(e),void delete n[s]}console.info("fetching",s);const o=await fetch(s);await t.put(s,o),a.resolve(o),delete n[s]}catch(e){console.error(s,e)}}))).then((()=>console.info("load complete",s.length,"files",s))).catch((e=>console.error(e))))}),5e3),console.info("installed")})())}),!1),t.addEventListener("activate",(function(e){return t.clients.claim()}));const a=e();t.onfetch=e=>{const t=new URL(e.request.url);e.waitUntil((async()=>{const c=(await a).external.map((e=>new URL(e,self.location.href)));t.host===self.location.host&&t.protocol===self.location.protocol&&"GET"===e.request.method||"GET"===e.request.method&&t.toString()!==new URL("/sw.js",self.location.href).toString()&&c.reduce(((e,o)=>e||o.host===t.host&&o.protocol===t.protocol),!1)?e.respondWith((async()=>{let a=e.request;"navigate"===a.mode&&"GET"===a.method&&a.headers.get("accept")?.includes("text/html")&&(t.pathname.endsWith("/")||(t.pathname+="/"),a=new Request(t,{headers:a.headers,method:a.method}));try{const e=await(n[a.url]??caches.match(a).catch((()=>{})));if(!e&&!self.navigator.onLine)return a=new Request("/offline/"),caches.match(a);if(self.navigator.onLine&&e?.headers.get("etag")){const t=await fetch(e.url,{method:"HEAD"});if(e.headers.get("etag")===t.headers.get("etag"))return s(e)}if(self.navigator.onLine){console.info("fetching",a.url);const e=await fetch(a);if(e.ok){const t=await caches.open(o);await t.put(a,e.clone())}return s(e)}return s(e)}catch(t){console.error(t);const o=await caches.match(a);if(o)return s(o);if("navigate"===e.request.mode&&"GET"===a.method&&a.headers.get("accept")?.includes("text/html")){const t=await caches.match(new URL("/404.html",e.request.url));if(t)return s(t)}throw t}})()):"GET"===e.request.method&&console.info("refusing to cache",t.toString())})())}})();
//# sourceMappingURL=sw.js.map