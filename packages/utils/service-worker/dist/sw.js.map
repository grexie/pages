{"version":3,"file":"sw.js","mappings":"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","sources":["webpack:///../../../../node_modules/@grexie/resolvable/lib/index.mjs","webpack:///./index.ts"],"sourcesContent":["export const createResolver = () => {\n  const resolver = {};\n  const promise = new Promise((resolve, reject) => {\n    let resolved = false;\n    Object.assign(resolver, {\n      get resolved() {\n        return resolved;\n      },\n      resolve: value => {\n        resolved = true;\n        resolve(value);\n      },\n      reject: err => {\n        resolved = true;\n        reject(err);\n      }\n    });\n  });\n  Object.assign(promise, resolver);\n  return promise;\n};\nexport class PromiseQueue {\n  #promises = [];\n  async add(promise) {\n    const previousPromises = [...this.#promises];\n    this.#promises.push(promise);\n    await Promise.all(previousPromises);\n  }\n  then(onfulfilled, onrejected) {\n    const length = this.#promises.length;\n    return Promise.all(this.#promises).then(async () => {\n      await new Promise(resolve => setImmediate(resolve));\n      if (length === this.#promises.length) {\n        return;\n      } else {\n        return this;\n      }\n    }).then(onfulfilled, onrejected);\n  }\n  catch(onrejected) {\n    return this.then(x => x, onrejected);\n  }\n  finally(onfinally) {\n    return this.then(x => x).finally(onfinally);\n  }\n}\n//# sourceMappingURL=index.mjs.map","/// <reference no-default-lib=\"true\" />\n/// <reference lib=\"ES2022\" />\n/// <reference lib=\"WebWorker\" />\n/// <reference types=\"./service-worker.js\" />\n\nimport { createResolver } from '@grexie/resolvable';\n\ninterface Manifest {\n  files: string[];\n  external: string[];\n}\n\nconst sw = self as unknown as ServiceWorkerGlobalScope;\n\nconst cacheName = 'grexie-cloud-v1.0.0';\n\nconst getCachePaths = async (cache: Cache): Promise<string[]> => {\n  const origin = new URL(location.href);\n  origin.pathname = '/';\n  origin.search = '';\n\n  const keys = await cache.keys(origin);\n  let out: string[] = [];\n  for (const key of keys) {\n    const r = key;\n    let pathname: string;\n    if (typeof key === 'string') {\n      out.push(new URL(key, location.href).pathname);\n    } else {\n      out.push(new URL(r.url, location.href).pathname);\n    }\n  }\n  return out;\n};\n\nconst manifestPromises: Record<string, Promise<Response>> = {};\n\nsw.addEventListener(\n  'install',\n  (event: ExtendableEvent) => {\n    console.info('installing...');\n\n    event.waitUntil(\n      (async () => {\n        const cache = await caches.open(cacheName);\n        let files: string[];\n        try {\n          const response = await fetch('/assets/site-manifest.json');\n          manifest.resolve(response.json());\n          files = (await manifest).files;\n        } catch (err) {\n          files = [];\n        }\n\n        const keys = await getCachePaths(cache);\n\n        for (const key of keys) {\n          if (files.includes(key)) {\n            files.splice(files.indexOf(key), 1);\n          }\n        }\n\n        const toDelete = new Set(keys);\n\n        for (const key of keys) {\n          if (files.includes(key)) {\n            toDelete.delete(key);\n          }\n        }\n\n        for (const key of toDelete) {\n          console.info('deleting', key);\n          cache.delete(new URL(key, location.href));\n        }\n\n        setTimeout(() => {\n          if (self.navigator.onLine) {\n            console.info('caching', files.length, 'files', files);\n\n            Promise.all(\n              files.map(async file => {\n                const url = new URL(file, location.href).toString();\n                const resolver = createResolver<Response>();\n                manifestPromises[url] = resolver;\n\n                try {\n                  const previousResponse = await cache.match(url);\n\n                  if (previousResponse?.headers.get('etag')) {\n                    const headResponse = await fetch(url, {\n                      method: 'HEAD',\n                    });\n\n                    if (\n                      previousResponse.headers.get('etag') ===\n                      headResponse.headers.get('etag')\n                    ) {\n                      resolver.resolve(previousResponse);\n                      delete manifestPromises[url];\n                      return;\n                    }\n                  }\n\n                  console.info('fetching', url);\n                  const response = await fetch(url);\n                  await cache.put(url, response);\n\n                  resolver.resolve(response);\n                  delete manifestPromises[url];\n                } catch (err) {\n                  console.error(url, err);\n                }\n              })\n            )\n              .then(() =>\n                console.info('load complete', files.length, 'files', files)\n              )\n              .catch(err => console.error(err));\n          }\n        }, 5000);\n\n        console.info('installed');\n      })()\n    );\n  },\n  false\n);\n\nsw.addEventListener('activate', function (event) {\n  return sw.clients.claim();\n});\n\nfunction cleanResponse(response: Response) {\n  if (response.type === 'opaque' || response.type === 'opaqueredirect') {\n    return response;\n  }\n\n  const clonedResponse = response.clone();\n\n  // Not all browsers support the Response.body stream, so fall back to reading\n  // the entire body into memory as a blob.\n  const bodyPromise =\n    'body' in clonedResponse\n      ? Promise.resolve(clonedResponse.body)\n      : (clonedResponse as any).blob();\n\n  return bodyPromise.then(async (body: Response['body']) => {\n    // new Response() is happy when passed either a stream or a Blob.\n    const headers = {} as any;\n    for (const header in clonedResponse.headers.keys()) {\n      headers[header] = clonedResponse.headers.get(header);\n    }\n    delete headers['X-Frame-Options'];\n    delete headers['X-Content-Type-Options'];\n\n    return new Response(body, {\n      headers: clonedResponse.headers,\n      status: clonedResponse.status,\n      statusText: clonedResponse.statusText,\n    });\n  });\n}\n\nconst manifest = createResolver<Manifest>();\n\nsw.onfetch = (event: FetchEvent) => {\n  const url = new URL(event.request.url);\n\n  event.waitUntil(\n    (async () => {\n      const external = (await manifest).external.map(\n        x => new URL(x, self.location.href)\n      );\n\n      if (\n        url.host !== self.location.host ||\n        url.protocol !== self.location.protocol ||\n        event.request.method !== 'GET'\n      ) {\n        if (\n          event.request.method !== 'GET' ||\n          url.toString() === new URL('/sw.js', self.location.href).toString() ||\n          !external.reduce(\n            (a, b) => a || (b.host === url.host && b.protocol === url.protocol),\n            false\n          )\n        ) {\n          if (event.request.method === 'GET') {\n            console.info('refusing to cache', url.toString());\n          }\n          return;\n        }\n      }\n\n      event.respondWith(\n        (async () => {\n          let request: URL | Request = event.request;\n\n          if (request.mode === 'navigate' && request.method === 'GET') {\n            if (request.headers.get('accept')?.includes('text/html')) {\n              if (!url.pathname.endsWith('/')) {\n                url.pathname += '/';\n              }\n              request = new Request(url, {\n                headers: request.headers,\n                method: request.method,\n              });\n            }\n          }\n\n          try {\n            const previousResponse = await (manifestPromises[request.url] ??\n              caches.match(request).catch(() => {}));\n\n            if (!previousResponse && !self.navigator.onLine) {\n              request = new Request('/offline/');\n              return caches.match(request);\n            }\n\n            if (\n              self.navigator.onLine &&\n              previousResponse?.headers.get('etag')\n            ) {\n              const headResponse = await fetch(previousResponse.url, {\n                method: 'HEAD',\n              });\n              if (\n                previousResponse.headers.get('etag') ===\n                headResponse.headers.get('etag')\n              ) {\n                return cleanResponse(previousResponse);\n              }\n            }\n\n            if (self.navigator.onLine) {\n              console.info('fetching', request.url);\n              const response = await fetch(request);\n\n              if (response.ok) {\n                const cache = await caches.open(cacheName);\n                await cache.put(request, response.clone());\n              }\n\n              return cleanResponse(response);\n            } else {\n              return cleanResponse(previousResponse);\n            }\n          } catch (err) {\n            console.error(err);\n            const r = await caches.match(request);\n\n            if (r) {\n              return cleanResponse(r);\n            } else {\n              if (\n                event.request.mode === 'navigate' &&\n                request.method === 'GET'\n              ) {\n                if (request.headers.get('accept')?.includes('text/html')) {\n                  const notFound = await caches.match(\n                    new URL('/404.html', event.request.url)\n                  );\n\n                  if (notFound) {\n                    return cleanResponse(notFound);\n                  }\n                }\n              }\n            }\n\n            throw err;\n          }\n        })()\n      );\n    })()\n  );\n};\n"],"names":["createResolver","resolver","promise","Promise","resolve","reject","resolved","Object","assign","value","err","sw","self","cacheName","manifestPromises","cleanResponse","response","type","clonedResponse","clone","body","blob","then","async","headers","header","keys","get","Response","status","statusText","addEventListener","event","console","info","waitUntil","cache","caches","open","files","fetch","manifest","json","origin","URL","location","href","pathname","search","out","key","r","push","url","getCachePaths","includes","splice","indexOf","toDelete","Set","delete","setTimeout","navigator","onLine","length","all","map","file","toString","previousResponse","match","headResponse","method","put","error","catch","clients","claim","onfetch","request","external","x","host","protocol","reduce","a","b","respondWith","mode","endsWith","Request","ok","notFound"],"sourceRoot":""}